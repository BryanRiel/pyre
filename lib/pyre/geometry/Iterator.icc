// -*- C++ -*-
// -*- coding: utf-8 -*-
//
// michael a.g. aïvázis
// orthologue
// (c) 1998-2016 all rights reserved
//

// code guard
#if !defined(pyre_geometry_Iterator_icc)
#error This header file contains implementation details of class pyre::geometry::Iterator
#endif


// meta-methods
template <typename indexT, typename orderT>
pyre::geometry::Iterator<indexT, orderT>::
Iterator(const index_type & begin, const index_type & end, const order_type & order) :
    _current(begin),
    _begin(begin),
    _end(end),
    _order(order)
{}


// interface
// access to the current value
template <typename indexT, typename orderT>
const typename pyre::geometry::Iterator<indexT, orderT>::index_type &
pyre::geometry::Iterator<indexT, orderT>::
operator* () const {
    // return the current value
    return _current;
}


// value update
template <typename indexT, typename orderT>
pyre::geometry::Iterator<indexT, orderT> &
pyre::geometry::Iterator<indexT, orderT>::
operator++ () {
    // pull the indices in order order
    for (auto dim : _order) {
        // get the associated limit
        auto limit = _end[dim];
        // get my current value for this component and increment it
        auto value = ++(_current[dim]);
        // if the value didn't overflow
        if (value < limit) {
            // save it
            _current[dim] = value;
            // all done
            return *this;
        }
        // otherwise, we overflowed; set this component to its starting value and grab the next one
        _current[dim] = _begin[dim];
    }

    // if we get this far, every component has overflowed
    _current = _end;

    // all done
    return *this;
}


// access to my limits
template <typename indexT, typename orderT>
const typename pyre::geometry::Iterator<indexT, orderT>::index_type &
pyre::geometry::Iterator<indexT, orderT>::
begin() const {
    // easy...
    return _begin;
}

template <typename indexT, typename orderT>
const typename pyre::geometry::Iterator<indexT, orderT>::index_type &
pyre::geometry::Iterator<indexT, orderT>::
end() const {
    // easy...
    return _end;
}


// operators on indices
template <typename indexT, typename orderT>
auto
pyre::geometry::
operator==(const Iterator<indexT, orderT> & one, const Iterator<indexT, orderT> & two) {
    // delegate to the standard algorithm
    return std::equal((*one).begin(), (*one).end(), (*two).begin());
}


template <typename indexT, typename orderT>
auto
pyre::geometry::
operator!=(const Iterator<indexT, orderT> & one, const Iterator<indexT, orderT> & two) {
    // easy enough
    return !(one == two);
}


// end of file
