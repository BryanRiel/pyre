// -*- C++ -*-
// -*- coding: utf-8 -*-
//
// michael a.g. aïvázis
// orthologue
// (c) 1998-2016 all rights reserved
//

// code guard
#if !defined(pyre_geometry_Tile_icc)
#error This header file contains implementation details of class pyre::geometry::Tile
#endif


// meta-methods
template <typename indexT, typename orderT>
pyre::geometry::Tile<indexT, orderT>::
Tile(index_type shape, order_type order) :
    Slice<indexT, orderT> { {}, shape, order }
{}


// interface
// accessors
template <typename indexT, typename orderT>
const auto &
pyre::geometry::Tile<indexT, orderT>::
shape() const {
    // easy enough...
    return this->high();
}


// compute the size of the tile
template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
size() const {
    // initialize
    size_type cells = 1;
    // go through my shape
    for (auto size : this->high()) {
        // scale up my size by the extent of this axis
        cells *= size;
    }
    // all done
    return cells;
}

// cell offset for a given index
template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
offset(const index_type & index) const {
    // initialize the offset
    size_type offset = 0;
    // and the running product
    size_type product = 1;
    // loop over the packing order
    for (auto axis : this->order()) {
        // update the offset
        offset += index[axis] * product;
        // update the product
        product *= this->high()[axis];
    }
    // all done
    return offset;
}


// index for a given cell offset
template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
index(size_type offset) const {
    // storage for the answer
    index_type index;
    // initialize the product of all the dimension extents
    auto product = size();

    // loop in reverse packing order
    for (int dim = index.size()-1; dim >=0; --dim) {
        // pull the current shape limit out of the product
        product /= this->high()[this->order()[dim]];
        // compute the index
        index[this->order()[dim]] = offset / product;
        // adjust the offset
        offset %= product;
    }

    // build an index and return it
    return index;
}


// the syntactic sugar
template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
operator[](const index_type & index) const {
    // delegate
    return offset(index);
}

template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
operator[](size_type offset) const {
    // delegate
    return index(offset);
}


// slicing
template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
slice(const order_type & order) const {
    // make a slice over the whole tile but with the given order
    return slice_type(this->low(), this->high(), order);
}


template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
slice(const index_type & begin, const index_type & end) const {
    // make a slice over the whole tile but with the given order
    return slice_type(begin, end, this->order());
}


template <typename indexT, typename orderT>
auto
pyre::geometry::Tile<indexT, orderT>::
slice(const index_type & begin, const index_type & end, const order_type & order) const {
    // make a slice over the whole tile but with the given order
    return slice_type(begin, end, order);
}


// end of file
