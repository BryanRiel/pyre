// -*- C++ -*-
//
// michael a.g. aïvázis
// orthologue
// (c) 1998-2016 all rights reserved
//

// code guard
#if !defined(pyre_geometry_Grid_icc)
#error This header file contains implementation details of class pyre::geometry::Grid
#endif

template <typename cellT, typename tileT, typename storageT>
pyre::geometry::Grid<cellT, tileT, storageT>::
Grid(tile_type shape, const storage_type & storage) :
    _shape { shape },
    _storage { storage },
    _cells { static_cast<cell_type *>(_storage.buffer()) }
    {}

template <typename cellT, typename tileT, typename storageT>
pyre::geometry::Grid<cellT, tileT, storageT>::
Grid(tile_type shape, storage_type && storage) :
    _shape { shape },
    _storage { std::move(storage) },
    _cells { static_cast<cell_type *>(_storage.buffer()) }
    {}


// interface
// grant write access to the grid at {offset}
template <typename cellT, typename tileT, typename storageT>
auto &
pyre::geometry::Grid<cellT, tileT, storageT>::
operator[](size_type offset)
{
    // dereference and return the value
    return _cells[offset];
}

// grant read access to the grid at {index}
template <typename cellT, typename tileT, typename storageT>
auto
pyre::geometry::Grid<cellT, tileT, storageT>::
operator[](size_type offset) const
{
    // dereference and return the value
    return _cells[offset];
}

// grant write access to the grid at {index}
template <typename cellT, typename tileT, typename storageT>
auto &
pyre::geometry::Grid<cellT, tileT, storageT>::
operator[](const index_type & index)
{
    // get my tile to compute the offset
    auto offset = _shape[index];
    // and delegate
    return (*this)[offset];
}


// grant read access to the grid at {index}
template <typename cellT, typename tileT, typename storageT>
auto
pyre::geometry::Grid<cellT, tileT, storageT>::
operator[](const index_type & index) const
{
    // get my tile to compute the offset
    auto offset = _shape[index];
    // and delegate
    return (*this)[offset];
}


// end of file
